{
    "collab_server" : "",
    "contents" : "#' Naive Bayes Landmarker\n#'\n#'\n#' @param dataset train data for the landmarker\n#' @param data.char dc\n#' @param k number of folds in cross-validation for estimating the accuracy\n#' of the landmarker\n#'\n#' @import e1071\nnb.landmarker <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  nb.acc <- numeric(k)\n  for (e in 1:k) {\n    m.nb = naiveBayes(formul, data=dataf[dataf$fold != e,])\n    prevs <- predict(m.nb, dataf[dataf$fold == e,], type=\"class\")\n    m.conf <- table(dataf[dataf$fold==e, \"class\"], prevs)\n    nb.acc[e] <- sum(diag(m.conf))/sum(m.conf)\n  }\n  mean(nb.acc)\n}\n\n#' dstump.landmarker_d1\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d1 <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=1))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    m.conf <- table(dataf[dataf$fold==e, \"class\"], prevs)\n    ds.acc[e] <- sum(diag(m.conf))/sum(m.conf)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d2\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d2 <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=2))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    m.conf <- table(dataf[dataf$fold==e, \"class\"], prevs)\n    ds.acc[e] <- sum(diag(m.conf)) / sum(m.conf)\n  }\n  mean(ds.acc)\n}\n\n\n#' dstump.landmarker_d3\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d3 <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=3))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    m.conf <- table(dataf[dataf$fold==e, \"class\"], prevs)\n    ds.acc[e] <- sum(diag(m.conf))/sum(m.conf)\n  }\n  mean(ds.acc)\n}\n\n#' classmajority.landmarker\n#'\n#' @inheritParams nb.landmarker\nclassmajority.landmarker <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- names(which.max(table(dataf$class)))\n    prevs <- rep(m.ds, nrow(dataf[dataf$fold == e,]))\n\n    ds.acc[e] <- sum(prevs == dataf[dataf$fold == e, \"class\"]) / sum(nrow(dataf[dataf$fold == e,]))\n  }\n  mean(ds.acc)\n}\n\n#' nb.landmarker.correlation\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import e1071\nnb.landmarker.correlation <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr,\n                             dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  nb.acc <- numeric(k)\n  for (e in 1:k) {\n    m.nb = naiveBayes(formul, data=dataf[dataf$fold != e,])\n    prevs <- predict(m.nb, dataf[dataf$fold == e,], type=\"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    prevs <- as.numeric(prevs)\n    truth <- as.numeric(truth)\n\n    nb.acc[e] <- cor(prevs, truth)\n  }\n  mean(nb.acc)\n}\n\n#' lda.landmarker.correlation\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import MASS\nlda.landmarker.correlation <- function (dataset, data.char, k = 10) {\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    dat <- dataf[dataf$fold != e,]\n    vars <- dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)]\n\n    new.vars <- vars[-caret::nearZeroVar(dat)]\n    if (length(new.vars)==0) {\n      formul <- create_formula(dataset[[1]]$attributes$target.attr, vars)\n    } else {\n      formul <- create_formula(dataset[[1]]$attributes$target.attr, new.vars)\n    }\n    m.ds <- lda(formul, data=dat)\n    prevs <- predict(m.ds, dataf[dataf$fold == e,])$class\n    truth <- dataf[dataf$fold == e,c(\"class\")]\n    prevs <- as.numeric(prevs)\n    truth <- as.numeric(truth)\n\n    ds.acc[e] <- cor(prevs, truth)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d1.correlation\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d1.correlation <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e,c(\"class\")]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=1))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e,c(\"class\")]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e,c(\"class\")]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e,c(\"class\")]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    }\n    ds.acc[e] <- cor(prevs, truth)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d2.correlation\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d2.correlation <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e,c(\"class\")]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=2))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e,c(\"class\")]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e,c(\"class\")]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e,c(\"class\")]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    }\n    ds.acc[e] <- cor(prevs, truth)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d3.correlation\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d3.correlation <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=3))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e, \"class\"]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e, \"class\"]\n      prevs <- as.numeric(prevs)\n      truth <- as.numeric(truth)\n    }\n    ds.acc[e] <- cor(prevs, truth)\n  }\n  mean(ds.acc)\n}\n\n#' classmajority.landmarker.correlation\n#'\n#' @inheritParams nb.landmarker\nclassmajority.landmarker.correlation <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- names(which.max(table(dataf$class)))\n    prevs <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    truth <- dataf[dataf$fold == e, \"class\"]\n    prevs <- as.numeric(prevs)\n    truth <- as.numeric(truth)\n\n    ds.acc[e] <- cor(prevs, truth)\n  }\n  mean(ds.acc)\n}\n\n#' nb.landmarker.entropy\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import e1071\nnb.landmarker.entropy <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  nb.acc <- numeric(k)\n  for (e in 1:k) {\n    m.nb = naiveBayes(formul, data=dataf[dataf$fold != e,])\n    prevs <- predict(m.nb, dataf[dataf$fold == e,], type=\"class\")\n    nb.acc[e] <- entropy::entropy(table(prevs))\n  }\n  mean(nb.acc)\n}\n\n#' dstump.landmarker_d1.entropy\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d1.entropy <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc = numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=1))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n    }\n    ds.acc[e] <- entropy::entropy(table(prevs))\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d2.entropy\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d2.entropy <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=2))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n    }\n    ds.acc[e] <- entropy::entropy(table(prevs))\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d3.entropy\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d3.entropy <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e,c(\"class\")]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=3))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n    }\n    ds.acc[e] <- entropy::entropy(table(prevs))\n  }\n  mean(ds.acc)\n}\n\n#' classmajority.landmarker.entropy\n#'\n#' @inheritParams nb.landmarker\nclassmajority.landmarker.entropy <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc = numeric(k)\n  for (e in 1:k) {\n    m.ds <- names(which.max(table(dataf$class)))\n    prevs <- rep(m.ds, nrow(dataf[dataf$fold == e,]))\n    ds.acc[e] <- entropy::entropy(table(prevs))\n  }\n  mean(ds.acc)\n}\n\n#' nb.landmarker.interinfo\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import e1071\nnb.landmarker.interinfo <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  nb.acc <- numeric(k)\n  for (e in 1:k) {\n    m.nb = naiveBayes(formul, data=dataf[dataf$fold != e,])\n    prevs <- predict(m.nb, dataf[dataf$fold == e,], type = \"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    mat <- cbind(prevs, truth)\n\n    m.ds <- names(which.max(table(dataf[dataf$fold != e, \"class\"])))\n    baseline <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    mat <- cbind(mat, baseline)\n\n    nb.acc[e] <- infotheo::interinformation(mat)\n  }\n  mean(nb.acc)\n}\n\n#' dstump.landmarker_d1.interinfo\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d1.interinfo <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=1))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    mat <- cbind(prevs, truth)\n\n    m.ds <- names(which.max(table(dataf[dataf$fold != e, \"class\"])))\n    baseline <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    mat <- cbind(mat, baseline)\n\n    ds.acc[e] <- infotheo::interinformation(mat)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d2.interinfo\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d2.interinfo <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=2))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    mat <- cbind(prevs, truth)\n\n    m.ds <- names(which.max(table(dataf[dataf$fold != e, \"class\"])))\n    baseline <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    mat <- cbind(mat, baseline)\n\n    ds.acc[e] <- infotheo::interinformation(mat)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d3.interinfo\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d3.interinfo <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=3))\n    prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    mat <- cbind(prevs, truth)\n\n    m.ds <- names(which.max(table(dataf[dataf$fold != e, \"class\"])))\n    baseline <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    mat <- cbind(mat, baseline)\n\n    ds.acc[e] <- infotheo::interinformation(mat)\n  }\n  mean(ds.acc)\n}\n\n#' classmajority.landmarker.interinfo\n#'\n#' @inheritParams nb.landmarker\nclassmajority.landmarker.interinfo <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc = numeric(k)\n  for (e in 1:k) {\n    m.ds <- names(which.max(table(dataf[dataf$fold != e,c(\"class\")])))\n    prevs <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    truth <- dataf[dataf$fold == e,c(\"class\")]\n    mat <- cbind(prevs, truth)\n\n    baseline <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    mat <- cbind(mat, baseline)\n\n    ds.acc[e] <- infotheo::interinformation(mat)\n  }\n  mean(ds.acc)\n}\n\n\n#' nb.landmarker.mutual.information\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import e1071\nnb.landmarker.mutual.information <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  nb.acc = numeric(k)\n  for (e in 1:k) {\n    m.nb = naiveBayes(formul, data=dataf[dataf$fold != e,])\n    prevs <- predict(m.nb, dataf[dataf$fold == e,], type=\"class\")\n    truth <- dataf[dataf$fold == e, \"class\"]\n    mat <- rbind(prevs, truth)\n\n    nb.acc[e] <- entropy::mi.empirical(mat)\n  }\n  mean(nb.acc)\n}\n\n#' dstump.landmarker_d1.mutual.information\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d1.mutual.information <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=1))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e, \"class\"]\n      mat <- rbind(prevs, truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e, \"class\"]\n      mat <- rbind(prevs, truth)\n    }\n    ds.acc[e] <- entropy::mi.empirical(mat)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d2.mutual.information\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d2.mutual.information <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=2))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e, \"class\"]\n      mat <- rbind(prevs, truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e, \"class\"]\n      mat <- rbind(prevs, truth)\n    }\n    ds.acc[e] <- entropy::mi.empirical(mat)\n  }\n  mean(ds.acc)\n}\n\n#' dstump.landmarker_d3.mutual.information\n#'\n#' @inheritParams nb.landmarker\n#'\n#' @import rpart\ndstump.landmarker_d3.mutual.information <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    if (length(unique(dataf[dataf$fold != e, \"class\"]))!=1) {\n      m.ds <- rpart(formul, data=dataf[dataf$fold != e,], control=rpart.control(maxdepth=3))\n      prevs <- predict(m.ds, dataf[dataf$fold == e,], type=\"class\")\n      truth <- dataf[dataf$fold == e,c(\"class\")]\n      mat <- rbind(prevs, truth)\n    } else {\n      prevs <- rep(unique(dataf[dataf$fold != e, \"class\"]), nrow(dataf[dataf$fold == e,]) )\n      truth <- dataf[dataf$fold == e, \"class\"]\n      mat <- rbind(prevs, truth)\n    }\n    ds.acc[e] <- entropy::mi.empirical(mat)\n  }\n  mean(ds.acc)\n}\n\n#' classmajority.landmarker.mutual.information\n#'\n#' @inheritParams nb.landmarker\nclassmajority.landmarker.mutual.information <- function (dataset, data.char, k = 10) {\n  formul <- create_formula(dataset[[1]]$attributes$target.attr, dataset[[1]]$attributes$attr.name[-length(dataset[[1]]$attributes$attr.name)])\n\n  dataf <- dataset[[2]]$frame\n  dataf$fold <- caret::createFolds(dataf$class, k=k, list=F)\n\n  ds.acc <- numeric(k)\n  for (e in 1:k) {\n    m.ds <- names(which.max(table(dataf$class)))\n    prevs <- as.factor(rep(m.ds, nrow(dataf[dataf$fold == e,])))\n    truth <- dataf[dataf$fold == e,c(\"class\")]\n    mat <- rbind(prevs, truth)\n\n    ds.acc[e] <- entropy::mi.empirical(mat)\n  }\n  mean(ds.acc)\n}\n",
    "created" : 1499246226084.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3977566731",
    "id" : "5FC54875",
    "lastKnownWriteTime" : 1499246267,
    "last_content_update" : 1499246267199,
    "path" : "~/Dropbox/AutoFuckingBagging/package/autoBagging/R/landmarkers.r",
    "project_path" : "R/landmarkers.r",
    "properties" : {
        "source_window_id" : "w8ntv0el2qy0q"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}